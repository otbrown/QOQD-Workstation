#!/usr/bin/bash

# qpeek
# Oliver Thomson Brown
# 2016-06-23
# simplified bash implementation of qpeek
# based on qpeek by Ohio Supercomputer Centre
# Troy Baer (C) 2001
#
# USAGE
# qpeek -{c|h|t} job_ID
#
# You can find the job_ID for your job using qstat. It should be of the form
# XXX.hart where XXX is the number assigned to your job. If you are using a
# task array the form is XXX-YY.hart, where YY is the task number.
#
# The tool option can be optionally omitted, in which case qpeek will use tail.
# You can optionally supply the number of lines to head and tail in format
# -{h|t}zz, where zz is the number of lines
#
# Options:
#	-c		Use the cat tool - will return the entire outfile.
#	-h		Use the head tool - will return the first ten lines of the outfile.
#	-t		Use the tail tool - will return the last ten lines of the outfile.
#
# Use man TOOL to find more information on each tool.
#
# Example calls:
#   qpeek 0.hart
#       - returns the output of tail JOB_FILE
#
#   qpeek -c 0.hart > 0.peek
#       - appends the output of cat JOB_FILE to 000.peek
#
#   qpeek -t20 0.hart
#       - returns the last 20 lines of the JOB_FILE

# variables
declare -r SPOOL=/var/spool/torque/spool/
declare -r DOMAIN=eps.hw.ac.uk
declare -r EXT=OU
declare -r JOB_REGEX=[0-9]\{1,\}-\{0,1\}[0-9]\{0,3\}\.hart
declare -r NUM_LINES_REGEX=-[ht][0-9]\{1,\}
declare -r EXEC_HOST_REGEX=[aeghrtu]\{4,5\}$
declare EXEC_HOST=""
declare TOOL=tail
declare LINE_OPT=""

# subfunctions
_help () {
    head -n37 $0 | tail -n34
    exit 0
}

build_path () {
    FNAME=${SPOOL}${1}.${DOMAIN}.${EXT}
}

get_num_lines () {
    LINE_OPT=-n${1:2}
}

# MAIN
# handle input arguments
if [ $# -gt 2 ]; then
    # this is an erroneous call
    echo "Too many arguments! Please check usage with qpeek --help"
    exit -1
elif [ $# -eq 0 ]; then
    # this is an erroneous call
    echo "No job ID provided. Please check usage with qpeek --help"
    exit -1
elif [ $# -eq 1 ]; then
    # this is either a default call or a cry for help
    if [[ $1 == --help || $1 == -help ]]; then
        _help
    elif [[ $1 =~ $JOB_REGEX ]]; then
        build_path $1
        EXEC_HOST=$(qstat -n1 $1 | grep -owE [aeghrtu]\{4,5\}$)
    else
        echo "Invalid input. Please check usage with qpeek --help"
        exit -1
    fi
elif [ $# -eq 2 ]; then
    # check tool request
    case $1 in
    	-c)
    		TOOL=cat
    		;;
    	-h*)
    		TOOL=head
            if [[ $1 =~ $NUM_LINES_REGEX ]]; then
                get_num_lines $1
            fi
    		;;
    	-t*)
    		TOOL=tail
            if [[ $1 =~ $NUM_LINES_REGEX ]]; then
                get_num_lines $1
            fi
            ;;
    	*)
    		echo "Unknown option -- see usage with qpeek --help."
    		exit -1
    esac
    # check job ID
    if [[ $2 =~ $JOB_REGEX ]]; then
        build_path $2
        EXEC_HOST=$(qstat -n1 $2 | grep -owE [aeghrtu]\{4,5\}$)
    else
        echo "Invalid job ID. See usage with qpeek --help"
        exit -1
    fi
fi

# check exec host has been assigned
if [[ $EXEC_HOST == "" ]];  then
    echo "Invalid job ID. See usage with qpeek --help"
    exit -1
fi

# check against local hostname
if [[ $(hostname) == ${EXEC_HOST}.${DOMAIN} ]]; then
    # final bit of error handling, check fname can be accessed
    if [ ! -f $FNAME ]; then
  	   echo "Cannot resolve outfile, or it is not a file."
  	   exit -1
    elif [ ! -r $FNAME ]; then
  	   echo "Outfile is not readable."
  	   exit -1
    fi

    # tool meet fname
    $TOOL $LINE_OPT $FNAME
else
    ssh -T ${USER}@${EXEC_HOST}.${DOMAIN} <<ENDSSH
    # final bit of error handling, check fname can be accessed
    if [ ! -f $FNAME ]; then
        ENDSSH
      	echo "Cannot resolve outfile, or it is not a file."
        exit -1
    elif [ ! -r $FNAME ]; then
        ENDSSH
      	echo "Outfile is not readable."
        exit -1
    fi

    # tool meet fname
    $TOOL $LINE_OPT $FNAME
    ENDSSH
fi

exit 0
